//paranthesis matching
#include<iostream>
#include<string.h>
using namespace std;
class stack
{
    public:
    int top;
    int size;
    char *arr;
    stack(int size);
    ~stack();
    void push(int x);
    int pop();
    int isfull();
    int isempty();
    int peek(int x);
    void display();
};
stack::stack(int size)
{
    this->size=size;
    arr=new char[size];
    top=-1;
}
stack::~stack()
{
    delete []arr;
}
void stack::push(int x)
{
    if(top==size-1)
    {
        cout<<"stack full";
    }
    else
    {
        top++;
        arr[top]=x;
        
    }
}
int stack::pop()
{
    int x=1;
    if(top==-1)
    {
        return -1;
    }
    else
    {
        x=arr[top];
        top--;
        
    }
    return x;
}
int stack::isfull()
{
    if(top==size-1)
    {
        return 1;
    }    
    else
    {
        return 0;
    }
}
int stack::isempty()
{
    if(top==-1)
    {
        return 1;
    }
        return 0;
}
int stack::peek(int pos)
{
    int x;
    if(top-pos+1<0||top-pos+1==size)
    {
        cout<<"invalid pos";
    }
    else
    
    {
        x=arr[top-pos+1];
    }
    return x;
}
void stack::display()
{
    for(int i=top;i>=0;i--)
    {
        cout<<arr[i]<<"-";
    }
}
bool isBalanced(char* exp){
 
    // Create a stac
     stack s((int)strlen(exp));
 
 
    // Process expression
    for (int i=0; i<strlen(exp); i++){
 
        // ( found: Push to stack
        if (exp[i] == '('){
            s.push(exp[i]);
 
            // ( found
        } else if (exp[i] == ')'){
 
            // ) and stack is empty: Unbalanced expression
            if (s.isempty()){
                return false;
 
                // ) and stack is not empty
            } else {
                s.pop();
            }
        }
    }
 
    // If stack is empty then balanced else unbalanced
    return s.isempty() ? true : false;
 
}
int main()
{
     char E[] = "((a+b)*(c-d))";
    cout << isBalanced(E) << endl;
 
    char F[] = "((a+b)*(c-d)))";
    cout << isBalanced(F) << endl;
 
    char G[] = "(((a+b)*(c-d))";
    cout << isBalanced(G) << endl;
    return 0;
    
    
}
